I: 源码编译的三个阶段
I.1:分词/词法分析
词法单元: 将代码字符串分解为词法单元
如: var a = 2; 分解为: var, a, =, 2, ;词法单元

I.2:解析/语法分析
将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。
抽象语法树中有一个叫做 VariableDeclaration 的顶级节点
接下来有一个 Indetifier 的子节点,值为 a
接下来有一个 NumbericLiteral 的子节点，值为 2

I.3:代码生成

II: 理解作用域
var a = 2;
编译器首先将这段程序分解为词法单元, 然后将词法单元解析成一个树结构.
但是当编译器开始进行代码生成时会如下处理:
遇到 var a, 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中，
如果是, 编译器会忽略该声明, 继续进行编译。
接下来编译器会为引擎生成运行时所需的代码, 这些代码被用来处理 a=2 这个赋值
操作。引擎运行时会首先询问作用域, 在当前的作用域集合中是否存在一个叫做 a 的变量
如果是，引擎就会使用这个变量。如果不是，就继续查找该变量

III: 作用域嵌套
当一个块或函数嵌套在另一个块或函数中时, 就发生了作用域的嵌套。
因此在当前作用域中无法找到某个变量时, 引擎就会在外层嵌套的作用域中继续查找，
直到找到该变量，或抵达最外层的作用域为止。

IV: 异常
在查询了所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。
如果在非"严格模式"下的话，全局作用域中会创建一个具有该名称的变量，并将其返回给引擎。

V: 作用域
作用域定义为一套规则,这套规则是用来管理引擎如何在当前作用域以及嵌套的子作用域中
根据标识符名称进行变量查找的。
